<?php

namespace Random;

use Random\Algorithm\AlgorithmInterface;

/**
 * Class Image
 */
class Image
{
    /**
     * Index of array element contains red channel value
     * @see Image::hexToRGB()
     */
    private const RED = 0;

    /**
     * Index of array element contains green channel value
     * @see Image::hexToRGB()
     */
    private const GREEN = 1;

    /**
     * Index of array element contains blue channel value
     * @see Image::hexToRGB()
     */
    private const BLUE = 2;

    /**
     * Index of array element contains x coordinate
     * @see Image::drawNoise()
     */
    private const X = 0;

    /**
     * Index of array element contains y coordinate
     * @see Image::drawNoise()
     */
    private const Y = 1;

    /**
     *
     */
    private const FONT_NAME = "Roboto-Regular.ttf";

    /**
     * @var int
     */
    private $wight;

    /**
     * @var int
     */
    private $height;

    /**
     * @var int
     */
    private $padding;

    /**
     * GD image resource
     *
     * @var resource
     */
    private $resource;

    /**
     * Background color
     *
     * @var string
     */
    private $backgroundHex;

    /**
     * Drawn pixel color index
     *
     * @var int
     */
    private $colorIndex;

    /**
     * Text color index
     *
     * @var int
     */
    private $textColorIndex;

    /**
     * Background color index
     *
     * @var int
     */
    private $backgroundIndex;

    /**
     * Burned colors
     *
     * @var array
     */
    private $burnedColors = [];

    /**
     * Convert $hexColor string to array of integers contains RGB channel values
     *
     * @param string $hexColor
     * @return mixed
     * @example
     *  static::hexToRGB("#FF0000"); // returns [0 => 255, 1 => 0, 2 => 0] - red color
     */
    private static function hexToRGB(string $hexColor)
    {
        return sscanf($hexColor, "#%02x%02x%02x");
    }

    /** @noinspection PhpUnusedPrivateMethodInspection */
    /**
     * Convert RGB (int $red, int $green, int $blue) to hex string
     * @param int $red
     * @param int $green
     * @param int $blue
     * @return string
     * @example
     *  static::rgbToHex(255, 0, 0); // returns "#FF0000"
     *
     */
    private static function rgbToHex(int $red, int $green, int $blue): string
    {
        return sprintf("#%02x%02x%02x", $red, $green, $blue);
    }

    /**
     * Draw point on background or burn drawn early point
     *
     * @param int $x
     * @param int $y
     * @return Image
     */
    public function mergePoint(int $x, int $y): self
    {
        $colorIndex = imagecolorat($this->resource, $x, $y);

        // color at coordinates $x, $y equal background color
        if ($colorIndex == $this->backgroundIndex) {
            return $this->drawPoint($x, $y, $this->colorIndex);
        } else {
            return $this->burnPoint($x, $y, $colorIndex);
        }
    }

    /**
     * Draw point on canvas
     *
     * @param int $x
     * @param int $y
     * @param int $colorIndex
     * @return Image
     */
    public function drawPoint(int $x, int $y, int $colorIndex): self
    {
        imagesetpixel($this->resource, $x, $y, $colorIndex);

        return $this;
    }

    /**
     * Burn pixel color by channel delimiter
     *
     * @param int $x
     * @param int $y
     * @param int $colorIndex
     * @return Image
     */
    public function burnPoint(int $x, int $y, int $colorIndex): self
    {
        $color = imagecolorsforindex($this->resource, $colorIndex);

        $color["red"] = $this->burnChannel($color["red"]);
        $color["green"] = $this->burnChannel($color["green"]);
        $color["blue"] = $this->burnChannel($color["blue"]);

        $existsColorIndex = imagecolorexact($this->resource, $color["red"], $color["green"], $color["blue"]);

        if ($existsColorIndex !== -1) {
            $burnedColorIndex = $existsColorIndex;
        } else {
            $burnedColorIndex = imagecolorallocate($this->resource, $color["red"], $color["green"], $color["blue"]);
            $this->burnedColors[] = $burnedColorIndex;
        }

        $this->drawPoint($x, $y, $burnedColorIndex);

        return $this;
    }

    private function burnChannel(int $channelValue): int
    {
        return (int)max(0, $channelValue / 1.5);
    }

    /**
     * Draw noise generated by $algorithm
     *
     * @param AlgorithmInterface $algorithm
     * @return Image
     */
    public function drawNoise(AlgorithmInterface $algorithm): self
    {
        foreach ($algorithm->sequence() as $coordinates) {
            $this->mergePoint($coordinates[static::X], $coordinates[static::Y]);
        }

        return $this;
    }

    /**
     * @param string $text
     * @return Image
     */
    public function drawText(string $text): self
    {
        imagettftext(
            $this->resource,
            12,
            0,
            $this->padding,
            $this->height - $this->padding,
            $this->textColorIndex,
            Application::getInstance()->getPath() . "/font/" . static::FONT_NAME,
            $text
        );

        return $this;
    }

    /**
     * Output image as .png file
     * @return Image
     */
    public function asPNG(): self
    {
        imagepng($this->resource);
        return $this;
    }

    /**
     * Image constructor.
     * @param int $wight - image width
     * @param int $height - image height
     * @param string $backgroundHex - image background color (ex.: "#FF0000" - to red background)
     * @param string $colorHex - drawn pixel color
     * @param string $textColorHex - drawn text color
     * @param int $padding - canvas padding
     */
    public function __construct(int $wight, int $height, string $backgroundHex, string $colorHex, string $textColorHex, int $padding)
    {
        $this->wight = $wight;
        $this->height = $height;
        $this->padding = $padding;

        $this->resource = imagecreate($wight, $height);

        $this->backgroundHex = $backgroundHex;
        $background = static::hexToRGB($backgroundHex);
        $this->backgroundIndex = imagecolorallocate(
            $this->resource,
            $background[static::RED],
            $background[static::GREEN],
            $background[static::BLUE]
        );

        $color = static::hexToRGB($colorHex);
        $this->colorIndex = imagecolorallocate(
            $this->resource,
            $color[static::RED],
            $color[static::GREEN],
            $color[static::BLUE]
        );

        $textColor = static::hexToRGB($textColorHex);
        $this->textColorIndex = imagecolorallocate(
            $this->resource,
            $textColor[static::RED],
            $textColor[static::GREEN],
            $textColor[static::BLUE]
        );
    }
}